<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为博客添加 Let's Encrypt 免费证书]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Let-s-Encrypt-%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[摘要：前段时间闹得沸沸扬扬的沃通丑闻事件最终以 Google，Firefox 相继宣布停止信任沃通和 StartCom 的证书宣告结束。按照沃通 CA 以及 StartCom 的证书在国内外的使用广泛程度，估计得有一大批网站需要更换 SSL 证书。本博客在建立之初就使用了 Let’s Encrypt 的免费证书，这个被沃通说成是「非常危险」的 CA，恰恰是一个不错的选择。 关于 HTTPS大概从去年开始，我偶尔会发现之前收藏的网站变成了未收藏状态，仔细一看才发现原来是这些网站的地址都变成了 https 开头。 越来越多的网站开始采用 HTTPS 加密，同时 Mozilla、Google 等公司也在促进 HTTPS 的普及。可以看到，全面启用 HTTPS 已经是大势所趋。 2016年10月13日 Firefox 用户加载的半数网页启用了 HTTPS2016年11月04日 Chrome 用户访问的网页 HTTPS 超过一半 什么是 HTTPS简单地来说，HTTPS 是建立在非对称加密方式上的保证通信双方信息传输安全性的一种超文本传输安全协议，能够防止信息在传送过程中被监听和篡改。 为什么要采用 HTTPS可能你会觉得，只有那些银行或者购物网站等涉及到财产安全的网站才需要采用 HTTPS 加密，或者只有登录的时候需要 HTTPS，一般的个人网站根本没有必要。但我想你肯定不会希望自己网站的图片都被替换成小广告吧（滑稽？ 另外，Mozilla 和 Google 等主流浏览器公司也在逐步淘汰 HTTP，终极目标是彻底使用 HTTPS 取代 HTTP。为此 Google 还于 2014 年 8 月 6 日宣布提高 HTTPS 网站的排名。 2015 年 4 月 30 日 Mozilla 宣布淘汰 HTTP2016 年 9 月 08 日 谷歌 Chrome56 正式将 HTTP 页面标记「不安全」 不加密的 HTTP 连接是不安全的，你和目标服务器之间的任何中间人能读取和操纵传输的数据，最简单的例子就是运营商劫持的页面跳转和小广告，你很可能根本不知道你看到的广告是否是网站发布的。而且中间人能够注入的代码不仅仅是看起来无害的广告，他们还可能注入具有恶意目的的代码。 为网站启用 HTTPS申请 Let’s Encrypt 证书Let’s Encrypt 官方提供了方便快捷的部署工具 Certbot，可以实现自动部署甚至自动续签。 安装 Certbot在 Ubuntu 上只需要简单的一行命令： 1$ sudo apt-get install letsencrypt 其他的发行版可以在这里选择。 使用 webroot 自动生成证书Certbot 支持多种不同的「插件」来获取证书，这里选择使用 webroot 插件，它可以在不停止 Web 服务器的前提下自动生成证书，使用 --webroot 参数指定网站的根目录。 1$ letsencrypt certonly --webroot -w /var/www/hexo -d blog.yizhilee.com 这样，在 /var/www/hexo 目录下创建临时文件 .well-known/acme-challenge ，通过这个文件来证明对域名 blog.yizhilee.com 的控制权，然后 Let’s Encrypt 验证服务器发出 HTTP 请求，验证每个请求的域的 DNS 解析，验证成功即颁发证书。 生成的 pem 和 key 在 /etc/letsencrypt/live/ 目录下 cert.pem 用户证书chain.pem 中间证书fullchain.pem 证书链, chain.pem + cert.pemprivkey.pem 证书私钥 配置 Nginx修改 Nginx 配置文件中关于证书的配置，配置文件可以通过 Mozilla SSL Configuration Generator 生成。 12ssl_certificate /etc/letsencrypt/live/blog.yizhilee.com/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/blog.yizhilee.com/privkey.pem; 然后重启 Nginx ，应该就可以看到小绿标了。 1$ sudo systemctl restart nginx 自动续期Let’s Encrypt 的证书有效期为 90 天，不过我们可以通过 crontab 定时运行命令更新证书。 先运行以下命令来测试证书的自动更新： 1letsencrypt renew --dry-run --agree-tos 如果一切正常，就可以编辑 crontab 定期运行以下命令： 1letsencrypt renew 执行频率只要小于 30 天一次即可，因为证书默认从有效期内第 60 天开始被视为即将过期。 HTTPS 评分完成配置之后可以使用以下两个工具对博客 HTTPS 配置的安全性进行评分。 Qualys SSL Labs’s SSL Server Test HTTP Security Report]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ssl部署</tag>
        <tag>https一键安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署Hexo到个人服务器]]></title>
    <url>%2F2018%2F09%2F07%2F%E9%83%A8%E7%BD%B2Hexo%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介一直想搭建一个完全属于自己掌控的博客小站，从搬瓦工上租了一个服务器，Godaddy上买了域名后终于可以开始博客的搭建了。这里我选择基于Nodejs的开源静态博客框架Hexo，其安装简单，文档丰富，支持MarkDown写作，配合上Git非常方便博客的保存和转移，对于我这种网页小白再适合不过了。虽然Hexo是静态博客，也同样有办法添加评论功能。下面将介绍我的配置具体步骤。 配置环境以下是我部署过程使用的环境： 主机： 搬瓦工VPS 操作系统： Centos 7 x86_64 (10GB 512MB) 部署具体过程搭建基础环境创建新的用户首先通过ssh登录到远程主机（一般VPS主机安装好系统后默认会打开ssh服务，并告诉对应的端口号） 1local$ ssh root@server_ip_address -p ssh_port_number 添加用户并设置密码 12remote# adduser your_user_idremote# passwd your_user_id 这里会弹出交互命令，输入并确认密码即可 1234Changing password for user your_user_id. New password: Retype new password: passwd: all authentication tokens updated successfully. 设置sudo权限（加入your_user_id到wheel组，CentOS默认wheel组成员拥有sudo的权限） 1remote# usermod -aG wheel your_user_id 现在就可以从root切换到your_user_id用户 1remote# su - your_user_id 安装Server这里我使用轻量级的HTTP服务器Nginx就足够了。继续之前的远程主机命令行： 123remote# sudo yum install epel-release //安装第三方Fedora源EPELremote# sudo yum install nginx //安装Nginxremote# sudo systemctl start nginx //启动Nginx服务 至此，如果访问VPS的IP地址，出现Ngnix的默认欢迎界面，那么恭喜，基本的Server环境就搭建成功了。下面开始部署Hexo博客。 部署Hexo目前实现的功能包括： 访问VPS的IP的根目录会直接跳转到Hexo博客主页 Git远端管理博客框架，方便随时随地在本地同步博客环境 通过“hexo generate &amp; deploy”命令一键更新博客 本地安装hexo现在先回到本地命令行。Hexo官方提供了清楚的英文版安装教程安装git(用于下载hexo在Github的源码) 1local$ sudo yum install git-core //如果是Ubuntu/Debian替换yum为apt-get 安装Node Version Manager(Node版本管理工具) 1local$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 这一步后建议重启本地主机或者重新登录使得nvm命令被自动识别。安装Node.js 1local$ nvm install stable 安装Hexo 1local$ npm install -g hexo-cli 至此，Hexo在本地就安装完毕了，接下来新建Hexo项目，例如这里我设置项目名为MyBlog: 1local$ hexo init MyBlog 新建一篇文章 1local$ hexo new your_post_title 这会生成your_post_title.md文件,现在便可以开始用MarkDown来直接写作了。写作配置等请直接参考Hexo官网的写作教程。生成静态网页 1local$ hexo g //g是generate的缩写 输入以下命令后，便可以本地通过浏览器访问http://localhost:4000预览博客了。 1local$ hexo s //s是server的缩写 这里我发现Hexo的一个优点是，在写作过程中，也可以直接通过刷新上述页面查看正在写作的文章效果，而不需要重新生成网页。 设定hexo部署相比直接部署到GitHub Page上，部署到个人VPS上稍复杂。网上主要有两种办法，一种是通过rsync,另外一种是git hook。前者更简单方便，但是需要在Server端运行rsync服务。本着博客系统尽量独立于系统环境的原则，这里我选择后者。本地安装hexo部署工具，直接在hexo博客文件夹根目录下运行： 1local$ npm install hexo-deployer-git --save 本地打开_config.yml文件，先设定基本的博客URL和根目录 1234# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://huangtengxq.comroot: / 这里有必要提一下Hexo生成博客网页的原理，当前面输入“hexo g”命令后，hexo会根据设定的主题，文章等开始创建网页内容、风格等，所有相关文件都会统一保存在public文件夹。public文件夹结构如下： 12345672017 //博客文件archives //博客文件css //网页风格images //图片index.html //索引网页js //javascriptlib //库文件 index.html即为hexo博客的主页，使用css目录中的文件渲染网页。这里要注意的是该文件夹的结构根据上面_config.yml中的url和root的值会有相应的变化。如果后面发现hexo网页缺失主题渲染的话，首先要看的就是index.html中所指向的css文件夹的位置是否正确。例如目前index.html中指定的css目录应该为： 1&lt;link href=&quot;/css/main.css?v=5.1.2&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 设定deploy到VPS的方式和hexo生成的网页文件夹的位置。deploy的目的就是把本地生成的public文件夹的内容上传到远程VPS中指定的一个文件夹(下面设定中的repo地址)，之后只需要设定Nginx，使得通过HTTP访问VPS时直接跳转到指定的文件夹中的index.html显示即可。例如这里指定的VPS上的文件夹为/home/your_user_id/work/repo/hexo_blog.git。值得注意的一点是hexo的git deploy工具是不支持配置ssh端口的(默认使用端口22)，而现在一般为了保证个人VPS安全性端口号都会设置成别的。好在在设置repo的url时可以直接指定ssh的端口号，指定方法如下: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://your_user_id@your_vps_ip_addr:your_vps_ssh_port/home/your_user_id/work/repo/hexo_blog.git branch: master 接下来在VPS主机上的对应位置创建这个文件，然后初始化为git远端目录。注意这里hexo_blog.git应该属于your_user_id用户组。 123remote# mkdir -p /home/your_user_id/work/repo/hexo_blog.gitremote# mkdir -p /home/your_user_id/work/hexo_public //创建用于Hexo博客网页访问的目录remote# git init --bare /home/your_user_id/work/repo/hexo_blog.git //该命令后会在目录下创建一些git有关的目录 配置git hook 12remote# cd /home/your_user_id/work/repo/hexo_blog.git/hooksremote# touch post-receive //新建文件post-receive 在post-receive中添加如下bash命令: 1git --work-tree=/home/your_user_id/work/hexo_public --git-dir=/home/your_user_id/work/repo/hexo_blog.git checkout -f 基本原理就是每次本地触发git deploy命令时，会主动提交public中的更新的文件到远程git仓库hexo_blog.git中，这时会触发post-receive中的命令,因此会从 /home/your_user_id/work/repo/hexo_blog.git 仓库下载默认分支到 /home/your_user_id/work/hexo_public中。这样hexo_public中就有了和本地public文件中一样的内容。主要这里有的博客里说要设置文件夹为git用户组(因此还要创建git用户名等等)，而根据我的配置，只需要保证hexo_blog.git和hexo_public都是属于your_user_id的用户组的话就能成功。这可能是因为我在前面repo中已经设置了通过your_user_id来提交的。 设置Nginx根目录和用户设置根目录指向/home/your_user_id/work/hexo_public，打开/etc/nginx/nginx.conf (建议先保存原始的文件)，这里由于hexo_public所属的用户组是 your_user_id,所以访问网页的时候会需要nginx以 your_user_id 的身份访问网页文件目录。从安全角度，这里不建议设置为 root用户。 123456789user your_user_id #修改用户为your_user_id,否则网页返回403 Forbidden错误... //忽略一部分没有更改的配置include /etc/nginx/conf.d/*.conf;server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /home/huangt/work/hexo_public; #修改这个地方的root的值&#125; 测试接下来就大功告成了，试试在本地运行： 1local$ hexo deploy &amp; generate 接下来就可以通过浏览器访问你的vps绑定的域名或者IP地址来欣赏你的博客了。 随时随地更新博客如果想在别的电脑上更新博客怎么办？可以将前面在本地建立的Hexo项目MyBlog也设置成Git项目，同时也将其上传到个人VPS的Git仓库。这样就可以随时随地快速恢复你的Hexo项目环境了。具体做法如下：设置Hexo项目为Git项目 1local$ git init your_hexo_blog_location //如果是安装本文设定的话 就是MyBlog文件夹的位置 远端VPS上建立Git仓库 1remote# git init --bare /home/your_user_id/work/repo/MyBlog.git //示例 本地设置git remote的目录指向上面VPS的位置 12local$ git remote add origin ssh://your_user_id@45.78.56.111:27350/home/your_user_id/work/repo/MyBlog.git //示例local$ git remote -v //检查远程仓库是否正确添加 提交本地Hexo项目并上传到远程Git仓库 12local$ git commit -m &quot;set_your_message_here&quot;local$ git push origin master 之后如果想要在别的电脑下载之前的MyBlog，只需要从远端仓库下载下来即可： 1local2$ git clone ssh://your_user_id@45.78.56.111:27350/home/your_user_id/work/repo/MyBlog.git 以后的修改或者写新的博客记得同时在本地提交以及远程push： 123local2$(MyBlog) git pull . //如果之前在别的电脑修改过则先从远程同步一下local2$(MyBlog) git commit -m &quot;set_your_message_here&quot; //本地提交local2$(MyBlog) git push . //远程提交 Git仓库有一点需要注意，如果MyBlog下面有从别的Git项目(例如你在themes/文件夹git clone了别的主题包，例如NextT主题),则建议在下次提交的时候不要提交这个Git项目到MyBlog项目，这样会导致混乱。(因此在新的本地环境下载MyBlog项目后需要重新git clone对应的Git子项目)。解决这个问题的一个办法是用repo工具来管理有不同Git子目录的文件夹。这里有兴趣的可以尝试一下。 总结到这里就基本完成了，希望对大家有所帮助。之后可以做的有意思的事情还有很多，例如添加博客评论功能、网站分析、留言等，我会在测试后继续更新。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>vps部署hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十分钟了解HTTPS]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3HTTPS%2F</url>
    <content type="text"><![CDATA[只要十分钟，十分钟你看了不吃亏，十分钟你看了不上当，十分钟就可以让你对HTTPS的话题对酒当歌侃侃而谈，来吧备上花生瓜子八宝粥让我们荡起双桨 走起~ 阅读本文需要您对HTTP有基本了解，读完大概需要十分钟左右。 一、为什么要用HTTPS——HTTP协议的缺陷 通信使用明文（不加密），内容可能会被窃听 不能验证通信方的身份，所以请求和响应都有可能是攻击者发送的 数据包在由A到B的过程中，可能经历很多次路由转发，这个过程中数据包可能会被劫持和替换，A和B都无法确定收到的信息是否就是对方发送的。 无法证明报文的完整性，可能是经过篡改的信息。 同样是在A到B传输过程中，数据包被劫持、篡改之后继续传输，虽然接收方收到的数据包就是发送方发送的那个，但是内容已经遭到篡改，这样无法保证报文的完整性。 二、HTTPS是怎么克服这些缺陷的？2.1 HTTPS是什么？HTTPS：在HTTP通信时增加一层TLS通信，以前是HTTP直接和TCP通信，现在HTTP先与TLS通信，再由TLS和TCP进行通信。HTTPS拥有加密、证书校验身份、准确性校验这些功能，避免了HTTP的三个缺陷。 TLS的前身是SSL，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。 HTTP建立通信时，只需要进行TCP三次握手就可以开始传输数据了，而HTTPS在建立通信时，先进行TCP三次握手，再进行TLS握手，然后开始发送数据。 2.2 HTTPS的加密功能加密技术分为： 共享密钥加密，也叫对称密钥加密，只有一把密钥，通信方必须先将密钥发送给接收方，然后接收方使用密钥对密文解密，但是密钥发送的过程很难保证安全，一旦密钥被窃取，就不能保证加密的安全了。 公开密钥加密，即非对称密钥加密，有两把密钥，公钥public key 和私钥private key 公钥是公开的，可以随意发布，任何人都可以获得。A使用B发布的公钥加密报文，B接收后使用自己的私钥进行解密，这样私钥不需要传输，也就不必担心被窃取的风险。 对称加密处理速度要比非对称加密要快，所以在保证安全的基础上，应多使用对称加密方式。TLS采用非对称加密的加密方式，HTTPS采用混合加密机制：大部分通信使用对称密钥加密，但首次交换共享密钥时是使用非对称加密的方式，这样就既保证了安全，又速度最快。 2.3 HTTPS的身份认证功能按照上文介绍的非对称加密方式，会有一个安全缺陷：客户端怎么知道拿到的公钥是否就是服务端发放的公钥呢，因为在拿到的过程中，公钥有可能被掉包。于是为了避免这个缺陷，引入了证书的概念。 公钥证书 为了保证公钥是目标服务器发行的公钥，需要使用权威第三方机构（以下称为CA机构）颁发的公钥证书： 服务器去CA机构申请证书，机构颁发加数字签名的公钥证书，数字签名可以使用CA机构的公钥来验证； 服务器把公钥证书以公开密钥加密方式传给客户端； 浏览器内会植入常用CA机构的公钥； 客户端从浏览器拿到CA机构的公钥，并用它验证收到的公钥证书的数字签名，验证通过，证明服务器的公钥值得信任，客户端就从公钥证书取出公钥。 总结一下就是服务器传递的公钥上有CA的签名，客户端通过验证签名证实服务器的身份，并安全地得到公钥。 HTTPS首次交换共享密钥使用的是非对称加密方式，这种加密方式会使用公钥证书来验证服务端的身份。而想要验证客户端的身份就不是那么容易了，需要用户去申请证书，而且权威机构的证书是要花钱的，所以客户端身份验证充满挑战。现状是，仅有特殊用途的业务实现了客户端证书，比如那些可支撑客户端证书支出费用的业务，例如银行网银就采用了客户端证书。 2.4 HTTPS的完整性校验功能在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。 三、HTTPS建立通信的过程简介HTTPS首次建立通信时，假设C是客户端client，S是服务器端server，以SSL为例： C/S会先进行TCP三次握手； 然后C发送Client Hello报文及其他SSL信息，表示开始SSL通信过程； S收到后回以Server Hello及其他SSL信息，此外S还发送公钥证书，随后发送Server Hello Done通知Client SSL握手协商部分结束 即SSL第一次握手结束，这个过程最重要的是S把公钥证书交给了C； C验证公钥证书有效性，然后取出公钥，然后： 回以Client Key Exchange报文，报文中包含通过公钥加密过的Pre-master-secret是一个随机密码串。 C接着发送Change Cipher Spec报文，告诉S此报文后的通信会用Pre-master-secret进行加密。 C发送Finished报文，并包含上述全部报文的整体校验值。这次握手协商能否成功，要看S是否正确解密该报文。 S收到加密过的pre-master secret，用自己的私钥得到pre-master secret，然后： 发送Change Cipher Spec报文 S发送Finished报文。 C/S使用pre-master secret经过一系列步骤生成master secret，使用master secret生成对称密钥session key，之后传输的收据均使用session key加密解密。 至此，SSL连接建立完成，这个过程最重要的是C把Pre-master-secret用上一步传递的公钥加密后传给S。之后开始进行HTTP通信，并用共享密钥对通信进行对称加密。 四、HTTPS的问题当使用SSL时，它的处理速度变慢： 通信速度变慢，因为除了HTTP请求和响应，还要进行SSL通信，通信量会增加 因为C/S端都要加密解密，更耗计算资源，SSL加速器可以改善S端问题 建议的是如果非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS进行通信。特别是访问量较多的网站在加密处理时，会承担较大的负载，可以仅在需要信息隐藏时才加密，以节约资源。但是查看淘宝、京东都是所有请求都采用的HTTPS，也有搜索到一些讲部分页面采用HTTP，部分页面采用HTTPS的部署方法的博文，因为现在我对部署这一块的东西还比较生疏，所以后续有时间再关注。 默认端口 HTTP默认端口80 HTTPS默认端口443]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>https部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo踩坑小记.md]]></title>
    <url>%2F2018%2F09%2F06%2F%E4%BD%BF%E7%94%A8Hexo%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-md%2F</url>
    <content type="text"><![CDATA[之前就装好了Hexo，但仍有好多未完成的部分，所有的细节堆起来就是一个大工程啦，记录一下坑坑们，那都是我逝去的青春π__π 1、语言Hexo语言设置在hexo项目根文件夹下的_config.yml中配置，找到language，不是chinese，不是zh-CN，我之前设置为zh-CN，会导致语言变为德文，文章标题下面的时间戳前面会变成“Veröffentlicht am”，要设为language: zh-Hans如果设置之后还不起作用，请到theme/next/languages/目录下查看是否有zh-Hans.yml（zh-EN.yml)文件，如果没有，请直接到next的Github下载相应文件添加即可。 2、文章折叠按照一般的Hexo教程进行安装，安装好后，首页文章没有折叠起来，全部是默认打开的，而我们希望每篇文章只显示部分内容，用户点击more的时候，再展开到详情页面。要做到这样，只需在.md文章里，在需要截取那段展示出来文字的地方添加 &lt;!-- More --&gt;，这样后面的文字都默认不显示，并出现一个More按钮更详细的说明，可以看这个链接 3、图片以及头像github page页的容量限制是300M，如果图片比较少，可以放在本地路径，我现在就是。使用方法：（注意下面1和2不可混用，用1就要卸载2的插件，用2就不要用1的语法，别问我怎么知道的） 1. Hexo官方插入图片方法 config.yml 文件中的 post_asset_folder 选项设为 true Hexo将会在你通过 hexo new [layout] 当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 1![](/example.jpg) ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&#123;% asset_img example.jpg This is an example image %&#125; 2. 使用hexo-asset-image插件插入图片 首先确认 _config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。 3. 使用千牛做图床可以参考这个链接如何使用七牛云做为图床？我采用他说的第一种方法，也就是七牛云的上传插件qiniu upload files，遇到了一个小障碍，就是在填写配置表格的时候，这个域名:不是你博客的域名，而是七牛生成的外链的域名，在七牛云—–&gt;marys存储空间(marys是我的存储空间名字)—-&gt;内容管理，里面可以看到你通过插件上传的图片，那个外链默认域名才是你需要填进去的域名，通过操作-&gt;复制外链可以直接复制：keyword:七牛云 图床 图片404 上传插件 4. 修改头像进去themes/next/_config.yml，搜索avatar，去掉#注释，avatar: 后接你的头像图片URL。头像图片放next主题下的images文件夹，url就写成/images/avatar.jpg 4、markdown标题不解析解析出来后，标题的#号仍然显示，并且标题没有加粗等这些格式：markdown标题标准写法需要在”#”和后面字符之间加一个空格，如果不加空格，有些引擎就解析不了 5、百度统计直接甩链接系列：NexT主题文档之百度统计 6、评论评论可以用多说评论框，但是用了多说评论框，你的文章就会自动被扒走，然后放到推酷这个网站上，你还啥都不知道（囧不懂脸）。所以我用的是国外的disqus，直接甩链接系列: 告别多说，拥抱 Disqus 解決 Hexo Comment ! 7、文章阅读量直接甩链接系列：NexT主题文档之阅读次数统计（LeanCloud) 8、Rss 安装生成插件npm install hexo-generator-feed --save 修改配置文件，在hexo根目录下的_config.yml中添加以下内容： 12345feed: type: atom path: atom.xml limit: 20 hub: 修改主题配置文件_config.yml，添加以下内容，以在页面中显示rss按钮：rss: /atom.xml]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置文件详解中文版]]></title>
    <url>%2F2018%2F09%2F06%2Fnginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[本文列出了nginx默认配置文件 nginx.conf的大部分命令，并加以中文注释说明，实际配置中可能没有这么复杂，这里只能作为一个参考阅读文档！ 一、nginx基本配置 定义Nginx运行的用户和用户组,系统中必须有此用户,可以是nologin1user www www; 启动进程,通常设置成和cpu的数量相等1worker_processes 1; 全局错误日志及PID文件12error_log /var/log/nginx/error.log; #错误日志定义等级，[ debug | info | notice | warn | error | crit ]pid /var/run/nginx.pid; 一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。1worker_rlimit_nofile 65535; 工作模式及连接数上限12345events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024;#单个后台worker process进程的最大并发链接数 （最大连接数=连接数*进程数） # multi_accept on; &#125; 设定http服务器，利用它的反向代理功能提供负载均衡支持123456789101112131415161718192021222324http &#123;#设定mime类型,类型由mime.type文件定义include /etc/nginx/mime.types;default_type application/octet-stream;#设定日志格式access_log /var/log/nginx/access.log;#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，#必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.sendfile on;#tcp_nopush on;#连接超时时间#keepalive_timeout 0;keepalive_timeout 65;tcp_nodelay on;#开启gzip压缩gzip on;gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;#设定请求缓冲client_header_buffer_size 1k;large_client_header_buffers 4 4k;#包含其它配置文件，如自定义的虚拟主机include /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*; 虚拟主机配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.xx.com; #设定本虚拟主机的访问日志 access_log logs/www.xx.com.access.log main; #默认请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /root; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ \.php$ &#123; root /root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name; include fastcgi_params; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /\.ht &#123; deny all; &#125; &#125;&#125; 二、nginx的负载均衡和代理配置 设定http服务器，利用它的反向代理功能提供负载均衡支持1234567891011121314151617181920http &#123; #设定mime类型,类型由mime.type文件定义include /etc/nginx/mime.types;default_type application/octet-stream;#设定日志格式access_log /var/log/nginx/access.log;#省略上文有的一些配置节点#。。。。。。。。。。#设定负载均衡的服务器列表upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口 server 192.168.8.2x:80 weight=1; server 192.168.8.3x:80 weight=6;&#125;upstream mysvr2 &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.x:80 weight=1; server 192.168.8.x:80 weight=6;&#125; 第一个虚拟服务器123456789101112131415161718192021222324252627 server &#123; #侦听192.168.8.x的80端口 listen 80; server_name 192.168.8.x; #对aspx后缀的进行负载均衡请求 location ~ .*\.aspx$ &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 proxy_pass http://mysvr ;#请求转向mysvr 定义的服务器列表 #以下是一些反向代理的配置. proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; &#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx配置</tag>
        <tag>nginx中文详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo next 添加打赏功能]]></title>
    <url>%2F2018%2F09%2F06%2F%E4%B8%BAhexo-next-%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[hexo 怎样添加 打赏功能按扭呢?其实如果你是next 主题的话,添加next自带打赏功能并不难的,官网也是有介绍,需要在主题配置文件中填入微信和支付宝收款二维码图片地址 即可开启该功能. 修改路径：/themes/next/_config.yml，取消注销符号“#” 1234&gt; reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！&gt; wechatpay: /path/to/wechat-reward-image&gt; alipay: /path/to/alipay-reward-image&gt; 但进入_config.yml 后你会发现, reward_comment 字段是并不存在的,需要你自己添加上去的.同时你必须要保证 wechatpay 和 alipay 字段下面是有值有数据的.打赏功能按钮才会正常运行.不然也是一样运行不了的.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>打赏插件</tag>
        <tag>hexo部署打赏插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F09%2F06%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。 Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。 git学习笔记（二） 发表于 2016-01-15 | 分类于 Git 这是一个系列的文章的第二篇，用来记录自己git的学习参考廖雪峰的官方网站. 1.添加远程仓库首先在github上创建一个新的仓库，Repository name填入你工作区的名字，其他默认。然后，在本地的仓库下运行命令： 1$ git remote add orgin &quot;新建仓库的SSH&quot; \\orgin是远程库的名字，一定要确保自己的电脑上有SSH Key。 如何添加SSH Key接着把本地库的所有内容推送到远程库上: 1$ git push -u orgin master \\用git push命令，实际上是把当前分支master推送到远程。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub. 2.从远程库克隆首先，登陆GitHub，创建一个新的仓库。勾选 Initialize this repository with a README，GitHub会自动创建一个 README.md 文件。接着克隆一个本地库： 1$ git clone &quot;SSH地址&quot; 接着 12$ cd gitskills$ ls 然后进入gitskills目录看看，已经有README.md文件了。 3.创建与合并分支首先，我们创建分支，然后切换到创建的分支： 123$ git checkout -b &lt;分支name&gt; \\-b参数表示创建并切换，相当于以下两条命令：$ git branch &lt;分支name&gt;$ git checkout &lt;分支name&gt; 然后，用 git branch 命令查看当前分支： 1$ git branch \\git branch命令会列出所有分支，当前分支前面会标一个*号。 然后在创建的分支上正常提交： 12$ git add readme.txt $ git commit -m &quot;branch test&quot; 切换回 master 分支： 1$ git checkout master 把创建的分支的工作成果合并到master分支上： 1$ git merge &lt;分支name&gt; \\git merge命令用于合并指定分支到当前分支。 删除创建的分支： 1$ git branch -d &lt;分支name&gt; 删除后，查看 branch： 1$ git branch 注意:当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用 git log –graph 命令可以看到分支合并图。 4.–no-ff 参数，表示禁用 Fast forward：1$ git merge --no-ff -m &quot;merge with no-ff&quot; &lt;分支name&gt; \\加上-m参数，把commit描述写进去 合并分支时，加上 **–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward** 合并就看不出来曾经做过合并。 5.Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：1$ git stash 用 git stash list 查看stash内容。恢复有两个办法：一是用 git stash apply 恢复，但是恢复后，stash内容并不删除，你需要用 git stash drop 来删除；另一种方式是用 git stash pop，恢复的同时把stash内容也删了。 6.多人协作： 查看远程库信息，使用 git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用 git push origin branch-name，如果推送失败，先用 git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用 git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用 git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用 git pull，如果有冲突，要先处理冲突。 7.创建标签： 命令 git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…” 可以指定标签信息； git tag -s -m “blablabla…” 可以用PGP签名标签； 命令 git tag 可以查看所有标签。 8.操作标签： 命令 git push origin 可以推送一个本地标签； 命令 git push origin –tags可以推送全部未推送过的本地标签； 命令 git tag -d 可以删除一个本地标签； 命令 git push origin :refs/tags/ 可以删除一个远程标签。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git使用</tag>
        <tag>git部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 SSH 隧道或 SS 来实现内网穿透]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%88%A9%E7%94%A8-SSH-%E9%9A%A7%E9%81%93%E6%88%96-SS-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[热爱工作的我，时不时需要在家办公。但是由于测试数据库，redis，es 都只能从公司内网访问，所以就需要一个从外网访问公司内网环境的方案。 准备工作首先需要一个在公司内网且有公网 IP 的机器，可以在这台机器上配置 SS Server 或者有这台机器的 SSH 权限。 获取 SS 账号或者 SSH 权限后，在本机执行以下操作，开始监听本地的 socks5 端口。 启动 socks 端口监听SS 方案 本机启动 SS 连接内网的 SS Server 找到 shadowsocks 客户端的本地接口配置，记下是 socks 还是 http 并且记录端口号。 比如我这个配置是 socks5 协议，地址 127.0.0.1 端口 1080 SSH 方案 本机终端执行命令ssh -D 1080 &lt;remote_user&gt;@&lt;remote_host&gt; -p &lt;port&gt; 配置 proxychains如果想要通过终端跑程序时候也走代理，那么需要安装 proxychains 1brew install proxychains-ng 安装完成后编辑 /usr/local/etc/proxychains.conf 文件，修改最后一行为 socks5 127.0.0.1 1080 保存退出。 此时已经大功告成，以后执行命令只要开头 proxychains4 即可通过代理穿透到内网访问。比如 12345678$ proxychains4 python api/run.py[proxychains] config file found: /usr/local/etc/proxychains.conf[proxychains] preloading /usr/local/Cellar/proxychains-ng/4.12_1/lib/libproxychains4.dylib[proxychains] DLL init: proxychains-ng 4.12[proxychains] DLL init: proxychains-ng 4.12Logger init with level 10[proxychains] Strict chain ... 127.0.0.1:1080 ... 192.168.11.122:3306 ... OK[proxychains] Strict chain ... 127.0.0.1:1080 ... 192.168.11.122:3306 ... OK 其他 GUI 软件当使用 Navicat 或 DataGrip 之类的 GUI 数据库客户端时候，只需要在 app 的代理设置填写一下 socks 协议监听地址和端口即可实现 app 全局流量通过代理穿透到内网执行。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>代理</tag>
        <tag>Terminal</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS服务器搭建Hexo博客教程]]></title>
    <url>%2F2018%2F09%2F06%2FVPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0. 配置文件 1. 实现字数统计功能和阅读时长 2. 添加顶部加载条 3. 动态背景 Canvas 4. 鼠标点击出现桃心效果 5. 修改文章内链接文本样式 6. 修改文章底部的那个带#号的标签 7. 在每篇文章末尾统一添加“本文结束”标记 \8. 代码块 8.1 自定义行内代码块样式 0. 配置文件在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。前者称为 站点配置文件 ，后者称为 主题配置文件 。 1. 实现字数统计功能和阅读时长效果如下：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>hexo设置</tag>
        <tag>hexo优化</tag>
      </tags>
  </entry>
</search>
